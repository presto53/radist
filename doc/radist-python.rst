=================
Библиотека Radist
=================

.. contents:: Оглавление

Философия
=========

В отличие от "канонического" использования radist питоновский модуль
практически не использует такие понятия как кластер и иже с ним. Единственная
"уступка" --- это методы cluster(), cluster_size() и работа cluster_exec с
all_nodes=False.

В модуле в основном речь идет о нодах (RadistNode). Именно от них и надо
"плясать". 

Так же в модуле есть некоторое количество вещей, не привязанных непосредственно
к *radist'у*.  Это `r_exec`, `r_popen2`, `r_popen3`, `MuxReader`,
`AdvMuxReader`, `get_file` и `pmap`.

Настройка
=========

**PYRADIST_RUNNER** задает то, чем запускаются процессы на удаленных машинах,
например:

.. code-block:: sh

    PYRADIST_RUNNER=/usr/local/radist/bin/r2sh sconfig.py

**PYRADIST_LRUNNER** задает то, чем запускаются процессы на локальной машине.

**PYRADIST_USER** задает пользователя, который будет запускать программы. Для
локального запуска используется `sudo -u пользователь`, для удаленного опция
`-l пользователь`.  То есть, в случае PYRADIST_USER=indexator и запуска id на
машине localhost будет выполнено `sudo -u indexator LRUNNER -c id`, а для
merger1.rambler.ru `r2sh -l indexator id`.

**Внимание:** если PYRADIST_USER начинается с `-`, то `RUNNER` запускается без
опции '-l', а на удаленной машине запускается `sudo -u пользователь sh -c
команда`. Тут идет вырезанный мат о том, как сильно я люблю идиотский `csh`.

**RADIST_CONF_*** задает положение файла для **get_r**. **IXSEARCH_SERVERMAP**
задает положение конфигурационного файла для **get_ix**.

С **IXSEARCH_SERVERMAP** и **RADIST_CONF_URL** все понятно: они задают
положение файла. Может быть всем, чем угодно. Единственное, не может получать
файл по `ssh` как `batch_sh.sh`. Не рекомендую задавать это как **ra://**:
получится бесконечная рекурсия.

Если задан **RADIST_CONF_PATH** или **RADIST_CONF_HOST**, то они будут склеены,
при этом по умолчанию **RADIST_CONF_HOST** пустая строка, а
**RADIST_CONF_PATH** `/config/radist.conf`.

Основные функции
================

**get_r** возвращает ноду с прочитанным `radist.conf`. 

**get_ix** возвращает ноду с `ixServers.cfg`.

Эти функции пытаются прочитать конфиг трижды. Положение конфигурационного файла
может задаваться переменными окружения (см. выше).  

**get_file** возвращает файловый объект, аргументом является строка с адресом. 

Поддерживаемые схемы: 

  * **http://** - оно и в африке http;
  * **ftp://** - оно и в антарктиде ftp;
  * **svn://** - на данный момент - это то же самое, что и http;
  * **-** - стандартный ввод;
  * **/**, **~** или просто путь к файлу - тот самый файл;
  * **ra://** - файл, который лежит в radist'е. Если адрес выглядит так:
    **ra://r.index.000//etc/passwd**,
    то это `/etc/passwd` на машине `/R/index/000`. Если так:
    **ra://r.index.000/current/db000.marry.hcs**, то это файл
    `/spool10/idx_4_6-search/000/current/db000.marry.hcs` (то есть
    `/R/index/000/dir` + `current/db000.marry.hcs`) на `merger1` (или где там
    живет нулевой цвет).

Кроме `ra://r.` еще работает `ra://ix.`. Идея точно такая же.

**Внимание:** r и ix часть получается вызовом get_r и get_ix. Они вызываются
только **один** раз.

**pmap** --- параллельный map. Запускает max_threads тредов. 

Еще параметры. 

  * **extra** --- словарь, который передается как ``**extra`` в функцию.
  * **ignore_exceptions** --- если True, то пропустить аргумент, который вызвал
    исключение при обработке.

Фабрика файлов
==============

**file_fabric** --- специальный метод для доступа по различным файловым схемам
унифицировано.

У **file_fabric** есть три полезных метода:

  * **add_reader**
  * **get_class**
  * **get_wrapper**, оно же file_fabric(URI)

Все объекты, которые обрабатывают файловые схемы порождены от абстрактного
класса `Content`.

Основные методы Content:

  * **is_me**
  * **get_content**
  * **get_file_write**
  * **can_target**
  * **get_host**


Нода
====

У ноды есть дети и атрибуты.

Основные методы ноды:

  * **get** - получить детей ноды в зависимости от аргументов;
  * **r_exec** - выполнить команду на ноде;
  * **r_popen2** - popen2 на ноде;
  * **r_popen3** - popen3 на ноде;
  * **r_pexec** - выполнение python функции на сервере;
  * **r_executor** - новая функция, которая будет выполнена на другом сервере;
  * **put_file** - положить файл на удаленную машину;
  * **cluster_exec** - выполнить команду на детях ноды;
  * **cluster_put** - положить файл на кластер;
  * **get_node** - получить новую ноду, дети которой задаются выражениями;
  * **get_default** - простой get, который в случае отсутствия нужной ноды и
    аргумента возвращает default значение.
  * **get_servers** - возвращает новую ноду, дети которой представляют все серверы

И некоторые другие:

  * **cluster** - возвращает ноды кластера;
  * **cluster_size** - размер кластера;
  * **get_attrs** - возвращает словарь атрибутов;

То, что вряд ли понадобится:

  * **add_attr** - добавить атрибут;
  * **add_child** - добавить ребенка;
  * **select** - get по словарю: используйте get вместо него;
  * **get_attr** - get по пути: используйте get вместо него.

Функции r_pexec и r_executor
----------------------------

Предназначены для выполнения обычных python функций на удаленных машинах.

Общие ограничения: 

  * функция не должна менять свои аргументы;
  * нельзя передавать генератор;
  * возвращаемое значение и аргументы должны быть pickle-able;
  * функция не должна трогать stdout/stderr;
  * не имеет смысла делать функцию, которая трогает глобальные переменные.

Ограничения на функции built-in функции: 

  * функция должна быть доступна на удаленной машине.

Ограничения на обычные функции:

  * должно быть возможно получить исходный код функции (то есть не получиться 
    передавать функции, набранные прямо в интерпретаторе, не получиться выполнить 
    функцию, которая находится только в .pyc/.pyo файле).
  * функция не должна пользоваться модулями, которые не существуют на удаленной 
    машине.

Функция может быть генератором или "чистым" итератором (т.е. iter(result) == result).
В этом случае нет необходимости ждать пока весь генератор выполнится. Я не проверял, 
что будет с бесконечным генератором.

Метод r_pexec просто и без затей возвращает результат выполнения на удаленной машине.
**Например**, посмотреть список всех пользователей на машине:

.. code-block:: python

    import pwd

    def sorted_userlist(arg=0):
        return sorted(pwd.getpwall(), key=lambda x: x[arg])

    print r.index.c000.r_pexec(pwd.getpwall)
    print r.index.c000.r_pexec(sorted_userlist, arg=1)


Обратите внимание, что r_pexec, в отличие от всех остальных r_*, 
не может быть использована с параметром user. 

r_executor
``````````

Метод r_executor возвращает функцию, которая будет выполнена на удаленной машине.
r_executor принимает параметр user.

**Внимание:** функцию, которую возвратил r_executor, можно вызвать только один 
раз. 

Если не надо выполнить функцию под другим пользователем, то лучше использовать r_pexec.

Пример использования:

.. code-block:: python

    func = self.node.r_executor(os.getuid, user='-root')
    assert func() == 0

Специальные ноды
----------------

Парсинг конфигов
````````````````

**RadistConf** - используется для чтения конфига `radist.conf`.

.. code-block:: python

    import radist
    r = radist.RadistConf('http://conf/config/radist.conf')

**IXConfig** - используется для чтения конфига `ixServers.cfg`.

.. code-block:: python

    import radist
    ix = radist.IXConfig('http://conf/config/ixServers.cfg')

**Используйте** `get_r` и `get_ix`, если нужны конфиги по умолчанию. 

**Внимание** `get_r` и `get_ix` читают файлы один раз. Если они были изменены,
придется залезть глубоко во внутрь библиотеки.

FakeNode
````````

"Фальшивая нода" - это нода, у которой может быть много детей с одним 
именем. 

Например: 

.. code-block:: python

    import radist
    r = radist.get_r()
    node = r.get_node('rccf/001', 'idxsrc/001', 'index/001')
    assert node.cluster_size() == 3

Мы создали ноду, у которой должны быть три ребенка с одинаковым именем. 
Обычная нода не может сделать этого по понятным причинам. Именно поэтому 
FakeNode создает детей последовательно присваивая им номера. В данном 
случае у node будут три ребенка с именем 0000, 0001, 0002.

Несмотря на то, что доступ через get затруднен "неправильными" именами,
дети не меняют своего имени, то есть node.cluster_exec('echo %(name)s')
покажет ожидаемый результат.

Для FakeNode.cluster_exec не имеет смысла параметр all_nodes, так как все
дети FakeNode имеют числовые имена, он всегда будет выполнять команды
на всех детях. 

**Например**, нам надо выполнить команду на цветах, заданных sys.argv[1:]
и на /R/index/common:

.. code-block:: python

    node = r.get_node('common', *sys.argv[1:])
    node.cluster_exec('echo %(name)s')


Эта программа при sys.argv = ['test.py', '000', '001'] должна вывести на экран:

::

    common
    000
    001


**Использование:** get_node и get_servers выдает на выход FakeNode.

ColoredNode
```````````

В основном обязана своим присутствием ixServers.cfg

Предположим, у нас есть файл

::

    www1.rambler.ru   -www000
    www2.rambler.ru   -www001
    www3.rambler.ru   -www000 
    ...


У www000 есть более одного бекэнда. ColoredNode создаст следующую иерархию:

::

    ix -> www -> c0001
              -> c0002
              -> c0003
              ...
              -> color000 -> <RadistNode 000 server: www1.rambler.ru>
                          -> <RadistNode 000 server: www3.rambler.ru>
              -> color001 -> <RadistNode 001 server: www2.rambler.ru>
              ...


В отличие от FakeNode, в ColoredNode нельзя добавить более одного ребенка 
с одинаковым не числовым именем.

**Использование:** IXConfig для www, wwwFast[0-9]+, cite, refindex2_backup

Атрибуты
--------

Еще есть атрибуты. Это обычные классы. Грубый хак. 
Когда надо распарсить атрибут ноды вызывается get_radist_value. Поэтому
для добавления атрибута мало написать класс, надо еще изменить словарь
в get_radist_value.

Для того, что бы get "видел" новый атрибут надо поправить словарь find_map
(опять--таки не очень хорошее решение).

Изюминка: метод get
===================

Метод get двуедин. Он может работать как select и как обычный доступ к объекту.

Выбор
-----

Предположим мы хотим выбрать все rccf ноды, которые 
живут на webbase01:

.. code-block:: python

    nodes = r.rccf.get(server='webbase01.rambler.ru')


Если атрибут надо не просто сравнить со значением, а сделать
что--то более интеллектуальное, можно передать callable объект.
**Например:** выбрать все цвета, которые заканчиваются на '0':

.. code-block:: python

    nodes = r.rccf.get(name=lambda x: x.endswith('0'))


Если указано несколько аргументов выполняется операция И. 
Например:

::

    In [11]: r.rccf.get(server='webbase01.rambler.ru', name=lambda x: x.endswith('0'))
    Out[11]: 
    [<RadistNode '030' server: 'webbase01.rambler.ru'>,
     <RadistNode '100' server: 'webbase01.rambler.ru'>,
     <RadistNode '080' server: 'webbase01.rambler.ru'>,
     <RadistNode '120' server: 'webbase01.rambler.ru'>]


Вещи, которые можно селектить описаны в radist.attrs.find_map. 
Сейчас это server, dir, space, spacelimit, name, tmp.

Выбор объекта
-------------

Это практически то же самое, что и прямой доступ к полю. Например
два следующих метода доступа эквивалентны:

.. code-block:: python

    r.get('index/000')
    r.index.c000


Отличие появляется, если мы запрашиваем несколько значений за раз:

::

    In [12]: r.rccf.get('000', '030')
    Out[12]: 
    [<RadistNode '000' server: 'webbase09.rambler.ru'>,
     <RadistNode '030' server: 'webbase01.rambler.ru'>]


В этом случае возвращается массив с теми элементами, что мы запросили.

Второе отличие - это обращение к атрибутам. Две следующие строки эквивалентны:

.. code-block:: python

    r.get('index/000/server')
    r.index.c000.primary.server


Имена атрибутов берутся из того же radist.attrs.find_map.

Магия
`````

Специальный селектор **#**: он выбирает кластер. 

get поддерживает shell--like синтаксис. Т.е. ``*``, [0-9], [a-z], ?.
Единственное различие: в стандартном модуле fnmatch не поддерживается 
[!^0-9] вместо этого надо писать [!0-9]. Кстати, shell это тоже поддерживает
(кроме csh, его все равно надо уничтожить!!! бва-ха-ха!!!).

Например нам надо выполнить команду на кластере и на ноде `common`:

.. code-block:: python

    node = r.index.get_node('#', 'common')
    result = node.cluster_run('echo %(name)s')
    # а теперь выберем все машины с нулевым цветом (index/000, rccf/000, ...)
    node = r.get_node('*/000')


get_default
-----------

Иногда мы знаем нормальное значение по умолчанию, в этом случае есть
специальный вариант get, он применяется только в случае одного аргумента
и только в случае простого взятия:

::

    In [14]: print r.get_default('index/999', None)
    None


Формирование команды для r_exec, r_popen3 и cluster_exec
========================================================

Используется стандартная питоновская подстановка. Например:

.. code-block:: python

    r.index.common.r_exec("echo %(name)s") # echo common


Для подстановки используется все тот же radist.attrs.find_map:

::

            'server'      => 'primary.server',
            'dir'         => 'primary.dir',
            'space'       => 'spacelimit.limit',
            'spacelimit'  => 'spacelimit.limit',
            'name'        => 'name',
            'tmp'         => 'primary.temp',


Возвращаемое значение
---------------------

**r_exec** возвращает exit status программы.

**cluster_exec** возвращает список кортежей `[(node1, exit_status1), (node2, exit_status2), ...]`.

**r_popen2** возвращает кортеж `(stdin, stdout)`.

**r_popen3** возвращает кортеж `(stdin, stdout, stderr)`.

**FIXME:** `cluster_exec` в режиме parallel и single возвращает статус `wait(2)`.

Ключи для cluster_exec
----------------------

По умолчанию команды выполняются последовательно, только на нодах 
из "кластера". 

  * **parallel**  - выполнять команду параллельно
  * **single**    - параллельно, на одном сервере только одна команда одновременно.
  * **all_nodes** - выполнять на всех детях.
  * **check**     - перед выполнением проверить, что все машины "живы".

Проверка на "живость" заключается в том, что если в течении 15 секунд не удается выполнить
`hostname` на удаленной машине, то машина считается дохлой. 

Типичное использование
----------------------

::

    In [1]: import radist

    In [2]: r = radist.get_r()

    In [3]: r.index.c001
    Out[3]: <RadistNode '001' server: 'index7.rambler.ru'>

    In [4]: r.index.c001.r_exec('ls')
    SUPER_1-SUPER-6
    SUPER_2-SUPER-6
    SUPER_SUPER-6
    trun
    Out[4]: 0

    In [5]: r.index.cluster_exec('ls -d /tmp/q* 2> /dev/null', parallel=True)
    /tmp/q
    /tmp/q
    /tmp/qwe
    /tmp/qwe.tar.bz2
    /tmp/qwe2.tar.bz2
    /tmp/q
    ...
    Out[5]: 
    [(<RadistNode '187' server: 'index3.rambler.ru'>, 256),
     (<RadistNode '108' server: 'merger1.rambler.ru'>, 0),
     (<RadistNode '172' server: 'index9.rambler.ru'>, 256),
     (<RadistNode '236' server: 'index8.rambler.ru'>, 256),
     (<RadistNode '046' server: 'index8.rambler.ru'>, 256),
     (<RadistNode '189' server: 'index4.rambler.ru'>, 256),
     (<RadistNode '174' server: 'index10.rambler.ru'>, 256),
     (<RadistNode '127' server: 'index7.rambler.ru'>, 256),
     (<RadistNode '238' server: 'index11.rambler.ru'>, 0),
     ...
    ]


Перемещение файлов
==================

put_file
--------

Кладет файл на удаленную машину. Файл может быть задан как имя файла (параметр
`file_name`) или как итератор по строкам (параметр `lines`).

Внимание, параметр должен указывать точное **имя файла**, а не название директории.

cluster_put
-----------

Функция кладет файл на кластер машин. Последовательно. Файл будет прочитан один
раз.  Если параметр lines не является списком или кортежем, он будет
преобразован в кортеж.

**Внимание**, этот метод применяется только для небольших файлов (конфиги,
скрипты). Для больших файлов использовать этот методы не желательно.

Использование ixServers.cfg
===========================

Несмотря на то, что до этого речь шла в основном о radist.conf, модуль может
работать и с ixServers.cfg:

.. code-block:: python

    import radist
    ix = radist.get_ix()
    ix.merger.cluster_exec('df -i /var', parallel=True)


Обратите внимание, что тут очень интенсивно применяются ColoredNode.  Например,
для www:

.. code-block:: python

    print ix.www.color000.cluster_size()
    print ix.www.cluster_size()



Директивы в ixServers.cfg
-------------------------

Не всегда можно однозначно интерпретировать имена ролей. По умолчанию, все роли
являются обычной нодой. В случае, если имя роли заканчивается цифрой, эта цифра
будет являться именем сервера. Путь разделяется по подчеркиваниям.

Специальные роли
````````````````

::

    #|regex class_name

Регулярное выражение и имя питоновского класса должны быть разделены пробелом.
Регулярное выражение должно делать match над всей ролью.  Если regex совпадает
с ролью, то используется соответствующий класс class_name.


Директории
``````````

::

    #/name/n server:dir:temp

(После **#/name/n** должен идти пробел)

Если, например, добавлена директива 

::

    #/index/001 some_server:some_dir:some_temp

то 

.. code-block:: python

    r = radist.get_ix()
    r.index.c001.primary.server # => some_server
    r.index.c001.primary.dir    # => some_dir
    r.index.c001.primary.temp   # => some_temp


Все директивы должны находится в начале файла ixServers.cfg.

Роли
````

  * Fixed --- роль рассматривается "как есть";
  * WWW --- создает "цветную" ноду.

Остальные роли очень узко специализированы.

Например
````````
::

    #!^cluster2$ Fixed
    #!^cluster3$ Fixed
    s1 -cluster2
    s2 -cluster3
    s3 -cluster2 -cluster3

Готовое решение
===============

cluster_read
------------

Специальная функция, которая параллельно читает результат выполнения команды на
кластере или на всех машинах ноды.

Возвращает словарь вида нода -> прочитанный вывод команды. Не проверяет код
возврата.

cluster_open
------------

Специальная функция, которая возвращает итератор с парами (*нода*, *строчка*).
У строчки убран разделитель.


Параллельный popen
------------------

Библиотека не содержит `cluster_popen3`. Он реализуется через `MuxReader`.
Пример:

.. code-block:: python

    stdouts = []
    for server in ix.refindex2.get_servers(all_nodes=True).get():
        stdin, stdout = server.r_popen2('hostname')
        stdin.close()
        stdouts.append(stdout)

    mr = radist.MuxReader(stdouts)
    result = (line for line in mr if line != '')


В результате в result будет содержаться выводи всех команд `hostname`. Нет
средства упорядочить результат по какому--бы то не было порядку.

Простой пример использования в mux_test2.py.

А еще есть `AdvMuxReader`. Он возвращает (obj, line). Его конструктор требует
список туплов вида `[(file1, obj1), (file2, obj2), ... ]`. Соответственно, если
мы прочитали строчку `'r-line'` из file1, то итератор вернет `(obj1, 'r-line')`.

Сам по себе
===========

Виртуальный кластер
-------------------

Если нужен собственный "виртуальный", нигде не описанный кластер, можно
использовать простоту ixServers.cfg для создания собственного кластера.

**Например**, нам надо выполнить какую--либо команду на машинах `www1`..`www20`:

.. code-block:: python

    clu = ['www%d -test' % x for x in range(1, 21)]
    node = radist.IXConfig(config=clu)
    print node.test.cluster_size()
    node.test.cluster_exec('echo %(server)s; hostname', parallel=True)


Выведет что--то типа:

::

    20
    www16
    www16.rambler.ru
    www1
    www1.rambler.ru
    www2
    www2.rambler.ru
    www15
    www15.rambler.ru
    www8
    www8.rambler.ru
    www5
    www5.rambler.ru
    www11
    www11.rambler.ru
    www7
    www7.rambler.ru
    www4
    www4.rambler.ru
    www20
    www20.rambler.ru
    www10
    www10.rambler.ru
    www17
    www17.rambler.ru
    www6
    www6.rambler.ru
    www9
    www9.rambler.ru
    ...

